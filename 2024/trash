    set.clearRetainingCapacity();
    // for (bad_zee.items) |i| {
    //     prints(intToArr(zee.items[i]));
    // }

    // z00, whb
    //

    // rnq -> mdv, rft, kkd, cjg
    // cwh, vvw fqf chv

    // printa(set.keys());
    printa(bad_zee.items.len);
    prints("");
    // for (set.keys()) |k| {
    //     prints(intToArr(k));
    // }

    // for (set.keys()) |k| {
    //     prints(intToArr(k));
    // }

    // for (bad_zee.items) |i| {
    //     myf.waitForInput();
    // }
    set.clearRetainingCapacity();
    _ = (try grid.get(zee.items[bad_zee.items[bad_zee.items.len - 1]]).?.getOr(signals, grid, 0, &set)).?;
    // for (set.keys()) |k| {
    //     printa(calcErrorsOverride(&exp, zee.items, grid, signals, k));
    //     // prints(intToArr(k));
    //     // myf.waitForInput();
    // }
    // printa(calcErrors(&exp, zee.items, grid, signals));
    // printa(grid.count() - zee.items.len);

    // for (swap_left.items, swap_right.items) |l, r| {
    //     std.debug.print("{s} {s}", .{ intToArr(l), intToArr(r) });
    // }

    fn findSwap(grid: *Grid, zee: []const u24) ![46]u24 {
        const mask: u24 = 0xFF;
        var buf = std.BoundedArray(u24, 46){};
        for (zee) |z| {
            const id = z & mask;
            if (!checkValid(id, z, grid)) {
                try buf.append(z);
            }
        }
    
        return buf.buffer;
    }

    
/// target_id is the masked out prefix, i.e x,z
fn checkValid(target_id: u24, id: u24, grid: *Grid) bool {
    const mask = 0xFF;

    const gate = grid.*.get(id).?;
    const pfx = gate.left >> 16;
    if (pfx == 'x' or pfx == 'y') {
        prints(intToArr(gate.left));
        if ((gate.left & mask) == target_id) return true;
        return false;
    }

    return checkValid(target_id, gate.left, grid) and checkValid(target_id, gate.right, grid);
}
fn swapGates(target_id: u24, id: u24, grid: *Grid) void {
    const mask = 0xFF;

    const gate = grid.*.get(id).?;
    const pfx = gate.left >> 16;
    if (pfx == 'x' or pfx == 'y') {
        if ((gate.left & mask) == target_id) return;
    }

    return checkValid(target_id, gate.left, grid) and checkValid(target_id, gate.right, grid);
}
