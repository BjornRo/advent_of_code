using System.Numerics;

namespace aoc.Solutions;

public class Day12
{
    readonly static int Dimension = 3;
    readonly struct ShapeData
    {
        public ShapeData(string row)
        {
            var x = row.Split(": ");
            var left = x[0].Split("x").Select(int.Parse).ToArray();
            Row = left[1];
            Col = left[0];
            Quantity = [.. x[1].Split().Select(int.Parse)];
        }
        public int Row { get; }
        public int Col { get; }
        public int[] Quantity { get; }
    }
    static char[][][] GenShapes(char[][] shape)
    {
        List<char[][]> newShapes = [shape];
        foreach (var ls in new[] { shape, Flip(shape) })
        {
            var s = ls;
            for (int i = 0; i < 3; i++)
            {
                s = Rotate(s);
                if (!newShapes.Any(ns => ns.Zip(s).All(e => e.First.SequenceEqual(e.Second))))
                    newShapes.Add(s);
            }
        }
        return [.. newShapes];
    }

    public static void Solve()
    {
        string[] data = File.ReadAllText("in/d12.txt").Replace("\r\n", "\n").TrimEnd().Split("\n\n");
        char[][][][] shapes = [.. data[..^1]
            .Select(
                elem => elem
                    .Split(":\n")[1]
                    .Split("\n")
                    .Select(x => x.ToCharArray().Select(x => x == '.' ? '\0' : x).ToArray())
                    .ToArray())
            .Select(GenShapes)
        ];
        ShapeData[] shapedata = [.. data[^1].Split("\n").Select(x => new ShapeData(x))];

        Console.WriteLine($"Part 1: {Part1(shapes, shapedata)}");
        // Console.WriteLine($"Part 2: {Part2(steps)}");
    }
    static bool FillMatrix(char[][] matrix, char[][] shape, int row, int col)
    {
        for (int i = 0; i < Dimension; i++)
            for (int j = 0; j < Dimension; j++)
            {
                if (shape[i][j] == '\0') continue;
                if (matrix[row + i][col + j] != '\0') return false;
                matrix[row + i][col + j] = shape[i][j];
            }
        return true;
    }
    static long Part1(char[][][][] shapes, ShapeData[] shapedata)
    {
        int fits = 0;

        bool Backtrack(char[][] matrix, int[] quantity, int row, int col, int shapeIndex, int shapeQuant)
        {
            // if (shapeNum >= shapes[0].Length) return false;
            if (shapeIndex >= quantity.Length) return true;
            if (quantity[shapeIndex] <= shapeQuant) return Backtrack(matrix, quantity, 0, 0, shapeIndex + 1, 0);


            for (int i = row; i <= matrix.Length - Dimension; i++)
            {
                for (int j = col; j <= matrix[0].Length - Dimension; j++)
                {
                    foreach (var shape in shapes[shapeIndex])
                    {
                        var cMatrix = DeepCopy(matrix);
                        if (FillMatrix(cMatrix, shape, i, j))
                        {
                            if (Backtrack(cMatrix, quantity, i, j, shapeIndex, shapeQuant + 1))
                            {
                                return true;
                            }
                        }
                    }
                }
            }
            return false;
        }


        foreach (var data in shapedata)
        {
            char[][] matrix = new char[data.Row][];
            for (int i = 0; i < data.Row; i++) matrix[i] = new char[data.Col];
            if (Backtrack(matrix, data.Quantity, 0, 0, 0, 0))
            {
                fits += 1;
            }
        }
        return fits;
    }
    public static char[][] Flip(char[][] matrix)
    {
        int rows = matrix.Length;
        char[][] flip = new char[rows][];
        for (int i = 0; i < rows; i++)
        {
            int cols = matrix[i].Length;
            flip[i] = new char[cols];
            for (int j = 0; j < cols; j++) flip[i][j] = matrix[i][cols - 1 - j];
        }
        return flip;
    }
    public static char[][] Transpose(char[][] matrix)
    {
        int rows = matrix.Length;
        int cols = matrix[0].Length;
        char[][] trans = new char[cols][];
        for (int i = 0; i < cols; i++)
        {
            trans[i] = new char[rows];
            for (int j = 0; j < rows; j++) trans[i][j] = matrix[j][i];
        }
        return trans;
    }
    static char[][] Rotate(char[][] matrix) => Transpose(Flip(matrix));
    public static char[][] DeepCopy(char[][] source)
    {
        char[][] copy = new char[source.Length][];
        for (int i = 0; i < source.Length; i++)
        {
            copy[i] = new char[source[i].Length];
            Array.Copy(source[i], copy[i], source[i].Length);
        }
        return copy;
    }
    static string FmtA(char[] array) => $"[{string.Join(", ", array)}]";
    static string FmtM(char[][] m)
    {
        List<string> f = [];
        foreach (var r in m) f.Add(FmtA([.. r.Select(x => x == '\0' ? ' ' : x)]));
        return string.Join("\n", f);
    }
    static void PrintM(char[][] m) => Console.WriteLine(FmtM(m));
}
