using System.Collections.Immutable;
using System.Linq;
using System.Numerics;

namespace aoc.Solutions;

public class Day10
{
    record Row(
        ImmutableArray<bool> Indicator,
        ImmutableArray<Vector<short>> Buttons,
        Vector<short> JoltReq,
        byte JoltLen
    );
    static Vector<short> CreateBtn(short[] arr)
    {
        var v = new short[Vector<short>.Count];
        for (int i = 0; i < arr.Length; i++)
            v[arr[i]] = 1;
        return ToVector(v);
    }
    static Vector<short> ToVector(short[] data)
    {
        if (data.Length >= Vector<short>.Count) return new Vector<short>(data);
        short[] padded = new short[Vector<short>.Count];
        Array.Copy(data, padded, data.Length);
        return new Vector<short>(padded);

    }
    static Row Parse(string row)
    {
        var s = row.Split();
        var ind = s[0][1..^1].Select(x => x == '#').ToImmutableArray();
        var buttons = s[1..^1].Select(
            x => x[1..^1]
                .Split(",")
                .Select(short.Parse)
                .ToArray()
            )
            // .OrderBy(x => x.Length)
            .Select(CreateBtn)
            .ToImmutableArray();
        short[] joltReqRaw = [.. s[^1][1..^1].Split(",").Select(short.Parse)];
        var joltreq = ToVector(joltReqRaw);
        return new Row(ind, buttons, joltreq, (byte)joltReqRaw.Length);
    }
    public static void Solve()
    {
        Row[] list = [.. File.ReadAllLines("in/d10t.txt").Select(Parse)];

        // Console.WriteLine($"Part 1: {Part1(list)}");
        Console.WriteLine($"Part 2: {Part2zz(list)}");
    }
    static int Part2zz(Row[] list)
    {
        static int Solver(Row elem)
        {
            var (_, buttons, targetJolt, joltLen) = elem;
            // short maxJolt = 0;
            // for (int i = 0; i < Vector<short>.Count; i++) maxJolt = short.Max(maxJolt, joltages[i]);
            // Dictionary<short[], short> visited = [];
            HashSet<short[]> visited = [];
            Dictionary<byte[], int> vvisited = [];
            HashSet<byte[]> vvvisited = [];

            byte[] Key(Vector<short> v)
            {
                var b = new byte[joltLen];
                for (int i = 0; i < joltLen; i++) b[i] = (byte)v[i];
                return b;
            }
            short SumShort(short[] arr) => arr.Aggregate((short)0, (sum, v) => (short)(sum + v));
            bool VecEven(Vector<short> v) => Vector.EqualsAll(v & Vector<short>.One, Vector<short>.Zero);

            var minPresses = int.MaxValue;

            void GreedyFind(Vector<short> jState, int totalPresses)
            {
                // if (!visited.Add(presses)) return null;
                if (totalPresses >= minPresses) return;
                var k = Key(jState);
                if (!vvvisited.Add(Key(jState))) return;
                if (vvisited.TryGetValue(k, out var oldVal))
                {
                    // if (totalPresses >= oldVal) return null;
                    return;
                }
                vvisited[k] = totalPresses;
                if (Vector.EqualsAll(jState, Vector<short>.Zero))
                {
                    Console.WriteLine(totalPresses);
                    if (totalPresses < minPresses)
                    {
                        minPresses = totalPresses;
                        return;
                    }
                    return;
                }

                // short[]? minValueArr = null;
                // short minValue = short.MaxValue;

                var sorted = buttons
                    .Select((button, i) => (button, i, newJState: jState - button))
                    .Where(x => !Vector.LessThanAny(x.newJState, Vector<short>.Zero))
                    .Select(x =>
                    {
                        var newPresses = new short[buttons.Length];
                        newPresses[x.i] += 1;

                        short newFactor = 1;
                        bool isEven = false;
                        if (VecEven(x.newJState))
                        {
                            isEven = true;
                            newFactor = 3;
                            x.newJState /= 2;
                        }
                        return (isEven, newPresses, newFactor, x.newJState);
                    })
                    .OrderByDescending(x => x.isEven)
                    .ToArray();

                foreach (var (_, newPresses, newFactor, newJState) in sorted)
                {
                    GreedyFind(newJState, totalPresses + newFactor);
                    // if (res != null)
                    // {
                    //     res = newPresses.Zip(res, (a, b) => (short)(a + (b * newFactor))).ToArray();
                    //     // return res;
                    //     var sum = SumShort(res);
                    //     if (sum < minValue)
                    //     {
                    //         minValue = sum;
                    //         minValueArr = res;
                    //     }
                    // return res;
                    // var sum = (short)res.Aggregate(0, (sum, v) => sum + v);
                    // if (sum < minValue)
                    // {
                    //     minValue = sum;
                    //     minValueArr = res;
                    // }
                    // }
                }
                // foreach (var (i, button) in buttons.Select((x, i) => (i, x)))
                // {
                //     var newJState = jState - button;
                //     if (Vector.LessThanAny(newJState, Vector<short>.Zero)) continue;

                //     var newPresses = new short[buttons.Length];
                //     newPresses[i] += 1;

                //     short newFactor = 1;
                //     if (VecEven(newJState))
                //     {
                //         newFactor = 3;
                //         newJState /= 2;
                //     }

                //     var res = GreedyFind(newJState, totalPresses + newFactor);
                //     if (res != null)
                //     {
                //         res = newPresses.Zip(res, (a, b) => (short)(a + (b * newFactor))).ToArray();
                //         var sum = SumShort(res);
                //         if (sum < minValue)
                //         {
                //             minValue = sum;
                //             minValueArr = res;
                //         }
                //         // return res;
                //         // var sum = (short)res.Aggregate(0, (sum, v) => sum + v);
                //         // if (sum < minValue)
                //         // {
                //         //     minValue = sum;
                //         //     minValueArr = res;
                //         // }
                //     }
                // }

                // return minValueArr;
            }

            GreedyFind(targetJolt, 0);
            // ?? throw new Exception("null found");

            // Print(res);
            // Console.WriteLine();
            // return minValueArr;
            return minPresses;
        }
        return list
            .Select((x, i) => (x, i + 1))
            // .OrderBy(x => -CountNonZero(x.x.JoltReq))
            // .AsParallel()
            // .WithDegreeOfParallelism(8)
            .Select(row =>
                {
                    // if (cache.TryGetValue(row.Item2, out var result)) return result;

                    var res = Solver(row.x);
                    // var value = res.Aggregate(0, (sum, press) => sum + press);
                    // Console.WriteLine($"{row.Item2} | {value} | {FmtA(res)}");
                    return res;
                })
            .Aggregate(0, (sum, v) => sum + v);
    }

    static int Part2z(Row[] list)
    {
        static short[] Solver(Row elem)
        {
            var (_, buttons, joltages, _) = elem;
            short maxJolt = 0;
            for (int i = 0; i < Vector<short>.Count; i++) maxJolt = short.Max(maxJolt, joltages[i]);

            short[]? Backtrack(short[] presses, int pIndex, Vector<short> jState)
            {
                if (Vector.EqualsAll(jState, joltages)) return presses;
                if (pIndex >= buttons.Length) return null;

                for (byte i = 0; i <= maxJolt; i++)
                {
                    var new_jState = jState + buttons[pIndex] * i;
                    if (!Vector.GreaterThanOrEqualAll(joltages, new_jState)) break;

                    presses[pIndex] = i;
                    var res = Backtrack(presses, pIndex + 1, new_jState);
                    if (res != null) return res;
                    presses[pIndex] = 0;
                }
                return null;
            }

            var res = Backtrack(new short[buttons.Length], 0, Vector<short>.Zero) ??
                throw new Exception("null found");
            // Print(res);
            // Console.WriteLine();
            return res;
        }
        return list
            .Select((x, i) => (x, i + 1))
            .OrderBy(x => -CountNonZero(x.x.JoltReq))
            .AsParallel()
            .WithDegreeOfParallelism(8)
            .Select(row =>
                {
                    if (cache.TryGetValue(row.Item2, out var result)) return result;

                    var res = Solver(row.x);
                    var value = res.Aggregate(0, (sum, press) => sum + press);
                    Console.WriteLine($"{row.Item2} | {value} | {FmtA(res)}");
                    return value;
                })
            .Aggregate(0, (sum, v) => sum + v);
    }
    static readonly Dictionary<int, int> cache = new()
    {
        { 45, 63 }, // [2, 13, 8, 4, 17, 12, 1, 0, 5, 1]
        { 22, 244 },// [4, 13, 12, 155, 15, 20, 9, 8, 8]
        { 74, 80 }, // [13, 17, 2, 17, 6, 10, 5, 10]
        { 77, 51 }, // [9, 12, 6, 1, 17, 2, 1, 3]
    };
    record P2State(byte[] JState, byte[] Presses);
    // static int Part2(Row[] list)
    // {
    //     static int Solver(Row elem)
    //     {
    //         var (target, buttons, joltages) = elem;
    //         var maxPresses = buttons.Select(v => v.Min(i => joltages[i])).ToArray();

    //         P2State[] states = [new P2State(new byte[joltages.Length], new byte[buttons.Length])];
    //         int generation = 0;
    //         while (states.Length != 0)
    //         {
    //             List<P2State> next_states = [];
    //             generation += 1;
    //             foreach (var (jState, pState) in states)
    //             {
    //                 foreach (var (presses, k) in buttons.Select((x, i) => (x, i)))
    //                 {
    //                     byte[] new_jState = [.. jState];
    //                     byte[] new_pState = [.. pState];
    //                     new_pState[k] += 1;
    //                     if (new_pState[k] > maxPresses[k]) continue;

    //                     foreach (var i in presses)
    //                     {
    //                         new_jState[i] += 1;
    //                     }

    //                     if (new_jState.SequenceEqual(joltages))
    //                     {
    //                         return generation;
    //                     }
    //                     if (!new_jState.Zip(joltages, (a, b) => a > b).Any(x => x))
    //                     {
    //                         // Console.WriteLine(generation);
    //                         // Print(new_jState);
    //                         // Print(joltages.ToArray());
    //                         // Console.WriteLine(new_jState.Zip(joltages, (a, b) => a > b).Any(x => x));
    //                         // Console.WriteLine();
    //                         // Print(new_jState);
    //                         // Print(joltages.ToArray());
    //                         // Console.WriteLine();
    //                         next_states.Add(new P2State(new_jState, new_pState));

    //                     }
    //                 }
    //             }
    //             states = [.. next_states];
    //         }
    //         throw new Exception("Not here");
    //     }
    //     var res = list
    //         .AsParallel()
    //         .Select(r =>
    //             {
    //                 var x = Solver(r);
    //                 Console.WriteLine(x);
    //                 return x;
    //             });
    //     return res.Aggregate(0, (sum, e) => sum + e);
    // }
    static string FmtA<T>(T[] array) => $"[{string.Join(", ", array)}]";

    static string FmtV<T>(Vector<T> v) where T : struct
    {
        T[] arr = new T[Vector<T>.Count];
        v.CopyTo(arr);
        return $"[{string.Join(", ", arr)}]";
    }
    static int CountNonZero<T>(Vector<T> v) where T : struct, IEquatable<T>
    {
        T[] arr = new T[Vector<T>.Count];
        v.CopyTo(arr);

        int count = 0;
        foreach (var x in arr) if (!x.Equals(default)) count++;
        return count;
    }
}
